#!/usr/bin/python3

# Module containing classes, variables, etc. for creating OVAL content
#
# Author: David Ries <ries@jovalcm.com>
# Author: Joy Latten <joy.latten@canonical.com>
# Copyright (C) 2015 Farnam Hall Ventures LLC
# Copyright (C) 2019 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# NOTES / TODOs
# This script creates OVAL ids based on the related CVE ID but does not
# currently increment the version number of generated elements when they
# change.

import datetime
import os
import random
import re
import shutil
import sys
import tempfile
from xml.sax.saxutils import escape


def recursive_rm(dirPath):
    '''recursively remove directory'''
    names = os.listdir(dirPath)
    for name in names:
        path = os.path.join(dirPath, name)
        if not os.path.isdir(path):
            os.unlink(path)
        else:
            recursive_rm(path)
    os.rmdir(dirPath)


class OvalGenerator:
    supported_oval_elements = ('definition', 'test', 'object', 'state',
                               'variable')
    generator_version = '1.1'
    oval_schema_version = '5.11.1'

    def __init__(self, release_codename, warn_method=False, outdir='./', prefix='', oval_format='dpkg', alpha=False):
        """ constructor, set defaults for instances """

        self.release_codename = release_codename
        self.warn = warn_method or self.warn
        self.tmpdir = tempfile.mkdtemp(prefix='oval_lib-')
        self.output_dir = outdir
        self.oval_format = oval_format
        if alpha:
            prefix = 'alpha.{0}'.format(prefix)
        self.output_filepath = \
            '{0}com.ubuntu.{1}.cve.oval.xml'.format(prefix, self.release_codename)
        self.ns = 'oval:com.ubuntu.{0}'.format(self.release_codename)

    def __del__(self):
        """ deconstructor, clean up """
        if os.path.exists(self.tmpdir):
            recursive_rm(self.tmpdir)

    def generate_cve_definition(self, cve):
        """ generate an OVAL definition based on parsed CVE data """

        header = cve['header']
        # if the multiplier is not large enough, the tests IDs will
        # overlap on things with large numbers of binary packages.
        # if we ever have an issue that touches more than 1,000,000
        # binary packages, that will cause a problem.
        id_base = int(re.sub('[^0-9]', '', header['Candidate'])) * 1000000
        if not self.unique_id_base(id_base, header['Source-note']):
            self.warn('Calculated id_base "{0}" based on candidate value "{1}" is not unique. Skipping CVE.'.format(id_base, header['Candidate']))

        # make test(s) for each package
        test_refs = []
        packages = cve['packages']
        for package in sorted(packages.keys()):
            releases = packages[package]['Releases']
            for release in sorted(releases.keys()):
                if release == self.release_codename:
                    release_status = releases[release]
                    if 'bin-pkgs' in release_status and release_status['bin-pkgs']:
                        test_ref = self.get_oval_test_for_package({
                            'name': package,
                            'binaries': release_status['bin-pkgs'],
                            'status': release_status['status'],
                            'note': release_status['note'],
                            'fix-version': release_status['fix-version'] if 'fix-version' in release_status else '',
                            'id_base': id_base + len(test_refs),
                            'source-note': header['Source-note']
                        })
                        if test_ref:
                            test_refs.append(test_ref)

        # if no packages for this release, then we're done
        if not len(test_refs):
            return False

        # convert CVE data to OVAL definition metadata
        mapping = {
            'ns': escape(self.ns),
            'id_base': id_base,
            'codename': escape(self.release_codename),
            'release_version': escape(self.release_version),
            'applicability_def_id': escape(
                self.release_applicability_definition_id),
            'cve_title': escape(header['Candidate']),
            'description': escape('{0} {1}'.format(header['Description'],
                                  header['Ubuntu-Description']).strip()),
            'priority': escape(header['Priority']),
            'criteria': '',
            'references': '',
            'notes': ''
        }

        # convert test_refs to criteria
        if len(test_refs) == 1:
            negation_attribute = 'negate = "true" ' \
                if 'negate' in test_refs[0] and test_refs[0]['negate'] else ''
            mapping['criteria'] = \
                '<criterion test_ref="{0}" comment="{1}" {2}/>'.format(
                    test_refs[0]['id'], escape(test_refs[0]['comment']), negation_attribute)
        else:
            criteria = []
            criteria.append('<criteria operator="OR">')
            for test_ref in test_refs:
                negation_attribute = 'negate = "true" ' \
                    if 'negate' in test_ref and test_ref['negate'] else ''
                criteria.append(
                    '    ' +
                    '<criterion test_ref="{0}" comment="{1}" {2}/>'.format(
                        test_ref['id'],
                        escape(test_ref['comment']), negation_attribute))
            criteria.append('</criteria>')
            mapping['criteria'] = '\n                    '.join(criteria)

        # convert notes
        if header['Notes']:
            mapping['notes'] = '\n                <oval:notes>' + \
                               '\n                    <oval:note>{0}</oval:note>'.format(escape(header['Notes'])) + \
                               '\n                </oval:notes>'

        # convert additional data <advisory> metadata elements
        advisory = []
        advisory.append('<severity>{0}</severity>'.format(
            escape(header['Priority'].title())))
        advisory.append(
            '<rights>Copyright (C) {0}Canonical Ltd.</rights>'.format(escape(
                header['PublicDate'].split('-', 1)[0] + ' '
                if header['PublicDate'] else '')))
        if header['PublicDate']:
            advisory.append('<public_date>{0}</public_date>'.format(
                escape(header['PublicDate'])))
        if header['PublicDateAtUSN']:
            advisory.append(
                '<public_date_at_usn>{0}</public_date_at_usn>'.format(escape(
                    header['PublicDateAtUSN'])))
        if header['Assigned-to']:
            advisory.append('<assigned_to>{0}</assigned_to>'.format(escape(
                header['Assigned-to'])))
        if header['Discovered-by']:
            advisory.append('<discovered_by>{0}</discovered_by>'.format(escape(
                header['Discovered-by'])))
        if header['CRD']:
            advisory.append('<crd>{0}</crd>'.format(escape(header['CRD'])))
        for bug in header['Bugs']:
            advisory.append('<bug>{0}</bug>'.format(escape(bug)))
        for ref in header['References']:
            if ref.startswith('https://cve.mitre'):
                cve_title = ref.split('=')[-1].strip()
                if not cve_title:
                    continue
                mapping['cve_title'] = escape(cve_title)
                mapping['references'] = '\n                    <reference source="CVE" ref_id="{0}" ref_url="{1}" />'.format(mapping['cve_title'], escape(ref))
            else:
                advisory.append('<ref>{0}</ref>'.format(escape(ref)))
        mapping['advisory_elements'] = '\n                        '.join(advisory)

        if self.oval_format == 'dpkg':
            mapping['os_release_check'] = """<extend_definition definition_ref="{applicability_def_id}" comment="Ubuntu {release_version} ({codename}) is installed." applicability_check="true" />""".format(**mapping)
        else:
            mapping['os_release_check'] = ''

        self.queue_element('definition', """
            <definition class="vulnerability" id="{ns}:def:{id_base}0" version="1">
                <metadata>
                    <title>{cve_title} on Ubuntu {release_version} ({codename}) - {priority}.</title>
                    <description>{description}</description>
                    <affected family="unix">
                        <platform>Ubuntu {release_version}</platform>
                    </affected>{references}
                    <advisory>
                        {advisory_elements}
                    </advisory>
                </metadata>{notes}
                <criteria>
                    {os_release_check}
                    {criteria}
                </criteria>
            </definition>\n""".format(**mapping))

    def get_oval_test_for_package(self, package):
        """ create OVAL test and dependent objects for this package status
                @package = {
                    'name'          : '<package name>',
                    'binaries'      : [ '<binary_pkg_name', '<binary_pkg_name', ... ],
                    'status'        : '<not-applicable | unknown | vulnerable | fixed>',
                    'note'          : '<a description of the status>',
                    'fix-version'   : '<the version in which the issue was fixed, if applicable>',
                    'id_base'       : a base for the integer section of the OVAL id,
                    'source-note'   : a note about the datasource for debugging
                }
        """

        if package['status'] == 'fixed' and not package['fix-version']:
            self.warn('"{0}" package in {1} is marked fixed, but missing a fix-version. Changing status to vulnerable.'.format(package['name'], package['source-note']))
            package['status'] = 'vulnerable'

        if package['status'] == 'not-applicable':
            # if the package status is not-applicable, skip it!
            return False
        elif package['status'] == 'not-vulnerable':
            # if the packaget status is not-vulnerable, skip it!
            return False
            """
            object_id = self.get_package_object_id(package['name'], package['id_base'], 1)

            test_title = "Returns true whether or not the '{0}' package exists.".format(package['name'])
            test_id = self.get_package_test_id(package['name'], package['id_base'], test_title, object_id, None, 1, 'any_exist')

            package['note'] = package['name'] + package['note']
            return {'id': test_id, 'comment': package['note'], 'negate': True}
            """
        elif package['status'] == 'vulnerable':
            object_id = self.get_package_object_id(package['name'], package['binaries'], package['id_base'])

            test_title = "Does the '{0}' package exist?".format(package['name'])
            test_id = self.get_package_test_id(package['name'], package['id_base'], test_title, object_id)

            package['note'] = package['name'] + package['note']
            return {'id': test_id, 'comment': package['note']}
        elif package['status'] == 'fixed':
            object_id = self.get_package_object_id(package['name'], package['binaries'], package['id_base'])

            state_id = self.get_package_version_state_id(package['id_base'], package['fix-version'])

            test_title = "Does the '{0}' package exist and is the version less than '{1}'?".format(package['name'], package['fix-version'])
            test_id = self.get_package_test_id(package['name'], package['id_base'], test_title, object_id, state_id)

            package['note'] = package['name'] + package['note']
            return {'id': test_id, 'comment': package['note']}
        else:
            if package['status'] != 'unknown':
                self.warn('"{0}" is not a supported package status. Outputting for "unknown" status.'.format(package['status']))

            if not hasattr(self, 'id_unknown_test'):
                self.id_unknown_test = '{0}:tst:10'.format(self.ns)
                self.queue_element('test', """
                    <ind-def:unknown_test id="{0}" check="all" comment="The result of this test is always UNKNOWN." version="1" />\n""".format(self.id_unknown_test))

            package['note'] = package['name'] + package['note']
            return {'id': self.id_unknown_test, 'comment': package['note']}

    def add_release_applicability_definition(self, version,
                                             kernel_version_pattern, id):
        """ add platform/release applicability OVAL definition for codename """

        mapping = {
            'ns': self.ns,
            'id_base': id,
            'codename': self.release_codename,
            'release_version': version,
            'kernel_version_pattern': kernel_version_pattern
        }
        self.release_version = version
        self.release_applicability_definition_id = \
            '{ns}:def:{id_base}0'.format(**mapping)

        if self.oval_format == 'dpkg':
            self.queue_element('definition', """
                <definition class="inventory" id="{ns}:def:{id_base}0" version="1">
                    <metadata>
                        <title>Check that Ubuntu {release_version} ({codename}) is installed.</title>
                        <description></description>
                    </metadata>
                    <criteria>
                        <criterion test_ref="{ns}:tst:{id_base}0" comment="The host is part of the unix family." />
                        <criterion test_ref="{ns}:tst:{id_base}1" comment="The host is running Ubuntu {codename}." />
                    </criteria>
                </definition>\n""".format(**mapping))
    
            self.queue_element('test', """
                <ind-def:family_test id="{ns}:tst:{id_base}0" check="at least one" check_existence="at_least_one_exists" version="1" comment="Is the host part of the unix family?">
                    <ind-def:object object_ref="{ns}:obj:{id_base}0"/>
                    <ind-def:state state_ref="{ns}:ste:{id_base}0"/>
                </ind-def:family_test>
    
                <ind-def:textfilecontent54_test id="{ns}:tst:{id_base}1" check="at least one" check_existence="at_least_one_exists" version="1" comment="Is the host running Ubuntu {codename}?">
                    <ind-def:object object_ref="{ns}:obj:{id_base}1"/>
                    <ind-def:state state_ref="{ns}:ste:{id_base}1"/>
                </ind-def:textfilecontent54_test>\n""".format(**mapping))
    
            # /etc/lsb-release has to be a single path, due to some
            # environments (namely snaps) not being allowed to list the
            # content of /etc/
            self.queue_element('object', """
                <ind-def:family_object id="{ns}:obj:{id_base}0" version="1" comment="The singleton family object."/>
    
                <ind-def:textfilecontent54_object id="{ns}:obj:{id_base}1" version="1" comment="The singleton release codename object.">
                    <ind-def:filepath>/etc/lsb-release</ind-def:filepath>
                    <ind-def:pattern operation="pattern match">^[\\s\\S]*DISTRIB_CODENAME=([a-z]+)$</ind-def:pattern>
                    <ind-def:instance datatype="int">1</ind-def:instance>
                </ind-def:textfilecontent54_object>\n""".format(**mapping))
    
            self.queue_element('state', """
                <ind-def:family_state id="{ns}:ste:{id_base}0" version="1" comment="The singleton family object.">
                    <ind-def:family>unix</ind-def:family>
                </ind-def:family_state>
    
                <ind-def:textfilecontent54_state id="{ns}:ste:{id_base}1" version="1" comment="Ubuntu {release_version}">
                    <ind-def:subexpression>{codename}</ind-def:subexpression>
                </ind-def:textfilecontent54_state>\n""".format(**mapping))

    def get_package_object_id(self, name, bin_pkgs, id_base, version=1):
        """ create unique object for each package and return its OVAL id """
        if not hasattr(self, 'package_objects'):
            self.package_objects = {}

        key = tuple(sorted(bin_pkgs))

        if key not in self.package_objects:
            object_id = '{0}:obj:{1}0'.format(self.ns, id_base)

            if len(bin_pkgs) > 1:
                # create variable for binary package names
                variable_id = '{0}:var:{1}0'.format(self.ns, id_base)
                if self.oval_format == 'dpkg':
                    variable_values = '</value>\n                        <value>'.join(bin_pkgs)
                    self.queue_element('variable', """
                        <constant_variable id="{0}" version="{1}" datatype="string" comment="'{2}' package binaries">
                            <value>{3}</value>
                        </constant_variable>\n""".format(variable_id, version, name, variable_values))

                    # create an object that references the variable
                    self.queue_element('object', """
                        <linux-def:dpkginfo_object id="{0}" version="{1}" comment="The '{2}' package binaries.">
                            <linux-def:name var_ref="{3}" var_check="at least one" />
                        </linux-def:dpkginfo_object>\n""".format(object_id, version, name, variable_id))

                else:
                    variable_values = '\s+(.*)</value>\n                        <value>^'.join(bin_pkgs)
                    self.queue_element('variable', """
                        <constant_variable id="{0}" version="{1}" datatype="string" comment="'{2}' package binaries">
                            <value>^{3}\s+(.*)</value>
                        </constant_variable>\n""".format(variable_id, version, name, variable_values))

                    # create an object that references the variable
                    self.queue_element('object', """
                        <ind-def:textfilecontent54_object id="{0}" version="{1}" comment="The '{2}' package binaries.">
                            <ind-def:path>.</ind-def:path>
                            <ind-def:filename>manifest</ind-def:filename>
                            <ind-def:pattern operation="pattern match" datatype="string" var_ref="{3}" var_check="at least one" />
                            <ind-def:instance operation="greater than or equal" datatype="int">1</ind-def:instance>
                        </ind-def:textfilecontent54_object>\n""".format(object_id, version, name, variable_id))

            else:
                if self.oval_format == 'dpkg':
                    # 1 binary package, so just use name in object (no variable)
                    self.queue_element('object', """
                        <linux-def:dpkginfo_object id="{0}" version="{1}" comment="The '{2}' package binary.">
                            <linux-def:name>{3}</linux-def:name>
                        </linux-def:dpkginfo_object>\n""".format(object_id, version, name, bin_pkgs[0]))
                else:
                    variable_id = '{0}:var:{1}0'.format(self.ns, id_base)
                    variable_values = '\s+(.*)</value>\n                        <value>^'.join(bin_pkgs)
                    self.queue_element('variable', """
                        <constant_variable id="{0}" version="{1}" datatype="string" comment="'{2}' package binaries">
                            <value>^{3}\s+(.*)</value>
                        </constant_variable>\n""".format(variable_id, version, name, variable_values))
                    self.queue_element('object', """
                        <ind-def:textfilecontent54_object id="{0}" version="{1}" comment="The '{2}' package binary.">
                            <ind-def:path>.</ind-def:path>
                            <ind-def:filename>manifest</ind-def:filename>
                            <ind-def:pattern operation="pattern match" datatype="string" var_ref="{3}" var_check="at least one" />
                            <ind-def:instance operation="greater than or equal" datatype="int">1</ind-def:instance>
                        </ind-def:textfilecontent54_object>\n""".format(object_id, version, name, variable_id))

            self.package_objects[key] = object_id

        return self.package_objects[key]

    def get_package_version_state_id(self, id_base, fix_version, version=1):
        """ create unique states for each version and return its OVAL id """
        if not hasattr(self, 'package_version_states'):
            self.package_version_states = {}

        key = fix_version
        if key not in self.package_version_states:
            state_id = '{0}:ste:{1}0'.format(self.ns, id_base)
            if self.oval_format == 'dpkg':
                self.queue_element('state', """
                    <linux-def:dpkginfo_state id="{0}" version="{1}" comment="The package version is less than '{2}'.">
                        <linux-def:evr datatype="debian_evr_string" operation="less than">{2}</linux-def:evr>
                    </linux-def:dpkginfo_state>\n""".format(state_id, version, fix_version))
            else:
                self.queue_element('state', """
                    <ind-def:textfilecontent54_state id="{0}" version="{1}" comment="The package version is less than '{2}'.">
                        <ind-def:subexpression datatype="debian_evr_string" operation="less than">{2}</ind-def:subexpression>
                    </ind-def:textfilecontent54_state>\n""".format(state_id, version, fix_version))
            self.package_version_states[key] = state_id

        return self.package_version_states[key]

    def get_package_test_id(self, name, id_base, test_title, object_id, state_id=None, version=1, check_existence='at_least_one_exists'):
        """ create unique test for each parameter set and return its OVAL id """
        if not hasattr(self, 'package_tests'):
            self.package_tests = {}

        key = (name, test_title, object_id, state_id)
        if key not in self.package_tests:
            test_id = '{0}:tst:{1}0'.format(self.ns, id_base)
            if self.oval_format == 'dpkg':
                state_ref = '\n                    <linux-def:state state_ref="{0}" />'.format(state_id) if state_id else ''
                self.queue_element('test', """
                    <linux-def:dpkginfo_test id="{0}" version="{1}" check_existence="{5}" check="at least one" comment="{2}">
                        <linux-def:object object_ref="{3}"/>{4}
                    </linux-def:dpkginfo_test>\n""".format(test_id, version, test_title, object_id, state_ref, check_existence))
            else:
                state_ref = '\n                    <ind-def:state state_ref="{0}" />'.format(state_id) if state_id else ''
                self.queue_element('test', """
                    <ind-def:textfilecontent54_test id="{0}" version="{1}" check_existence="{5}" check="at least one" comment="{2}">
                        <ind-def:object object_ref="{3}"/>{4}
                    </ind-def:textfilecontent54_test>\n""".format(test_id, version, test_title, object_id, state_ref, check_existence))
            self.package_tests[key] = test_id

        return self.package_tests[key]

    def _open(self, fn, mode, encoding='utf-8'):
        """ open file """
        fd = None
        if sys.version_info[0] < 3:
            fd = open(fn, mode=mode)
        else:
            fd = open(fn, mode=mode, encoding=encoding)
        return fd

    def queue_element(self, element, xml):
        """ add an OVAL element to an output queue file """
        if element not in OvalGenerator.supported_oval_elements:
            self.warn('"{0}" is not a supported OVAL element.'.format(element))
            return

        if not hasattr(self, 'tmp'):
            self.tmp = {}
            self.tmp_n = random.randrange(1000000, 9999999)

        if element not in self.tmp:
            self.tmp[element] = self._open(os.path.join(self.tmpdir,
                                           './queue.{0}.{1}.xml'.format(
                                               self.tmp_n, element)), 'wt')

        # trim and fix indenting (assumes fragment is nicely indented internally)
        xml = xml.strip('\n')
        base_indent = re.match(r'\s*', xml).group(0)
        xml = re.sub('^{0}'.format(base_indent), '        ', xml, 0,
                     re.MULTILINE)

        self.tmp[element].write(xml + '\n')

    def write_to_file(self):
        """ dequeue all elements into one OVAL definitions file and clean up """
        # close queue files for writing and then open for reading
        for key in self.tmp:
            self.tmp[key].close()
            self.tmp[key] = self._open(self.tmp[key].name, 'rt')

        tmp = os.path.join(self.tmpdir, self.output_filepath)
        with self._open(tmp, 'wt') as f:
            # add header
            oval_timestamp = datetime.datetime.utcnow().strftime(
                '%Y-%m-%dT%H:%M:%S')
            f.write("""<oval_definitions
    xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5"
    xmlns:ind-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
    xmlns:oval="http://oval.mitre.org/XMLSchema/oval-common-5"
    xmlns:unix-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"
    xmlns:linux-def="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://oval.mitre.org/XMLSchema/oval-common-5 oval-common-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5 oval-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#independent independent-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#unix unix-definitions-schema.xsd   http://oval.mitre.org/XMLSchema/oval-definitions-5#macos linux-definitions-schema.xsd">

    <generator>
        <oval:product_name>Canonical CVE OVAL Generator</oval:product_name>
        <oval:product_version>{0}</oval:product_version>
        <oval:schema_version>{1}</oval:schema_version>
        <oval:timestamp>{2}</oval:timestamp>
    </generator>\n""".format(OvalGenerator.generator_version, OvalGenerator.oval_schema_version, oval_timestamp))

            # add queued file content
            for element in OvalGenerator.supported_oval_elements:
                if element in self.tmp:
                    f.write("\n    <{0}s>\n".format(element))
                    f.write(self.tmp[element].read().rstrip())
                    f.write("\n    </{0}s>".format(element))

            # add footer
            f.write("\n</oval_definitions>")

        # close and delete queue files
        for key in self.tmp:
            self.tmp[key].close()
            os.remove(self.tmp[key].name)

        # close self.output_filepath and move into place
        f.close()
        shutil.move(tmp, os.path.join(self.output_dir, self.output_filepath))

    def unique_id_base(self, id_base, note):
        """ queue a warning message """
        if not hasattr(self, 'id_bases'):
            self.id_bases = {}
        is_unique = id_base not in self.id_bases.keys()
        if not is_unique:
            self.warn('ID Base collision {0} in {1} and {2}.'.format(
                id_base, note, self.id_bases[id_base]))
        self.id_bases[id_base] = note
        return is_unique

    def warn(self, message):
        """ print a warning message """
        print('WARNING: {0}'.format(message))
